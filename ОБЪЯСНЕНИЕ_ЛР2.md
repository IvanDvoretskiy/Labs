# Лабораторна робота №2 - Основи програмування та умовні конструкції

## Опис роботи
Лабораторна робота №2 (Варіант 3) включає вісім завдань, які демонструють основні принципи програмування: лінійні обчислення, умовні конструкції (if...else), структуру switch...case, валідацію даних та математичні розрахунки.

---

## Структура роботи

### **Завдання 1-2: Лінійні функції**
### **Завдання 3-6: Умовні конструкції (if...else)**
### **Завдання 7-8: Структура switch...case**

---

## Завдання 1: Площа кола за довжиною (лінійна функція)

### Функція: `calculate_first()`
```javascript
function calculate_first() {
    const circle_length = parseFloat(document.getElementById('circle_length').value);
    
    if (isNaN(circle_length)) {
        document.getElementById('result_1').innerText = 'Результат: Будь ласка, введіть довжину кола';
        return;
    }
    
    if (circle_length <= 0) {
        document.getElementById('result_1').innerText = 'Результат: Довжина кола має бути більше 0';
        return;
    }
    
    const radius = circle_length / (2 * Math.PI);
    const area = Math.PI * Math.pow(radius, 2);
    
    document.getElementById('result_1').innerText = `Площа кола: ${area.toFixed(2)}`;
}
```

**Призначення:** Обчислення площі кола за відомою довжиною його окружності

**Математичний алгоритм:**
1. **Формула довжини кола:** `L = 2πr`
2. **Знаходження радіуса:** `r = L / (2π)`
3. **Формула площі кола:** `S = πr²`
4. **Підстановка:** `S = π * (L / (2π))² = L² / (4π)`

**Валідація даних:**
- Перевірка на коректність введення (`isNaN()`)
- Перевірка на додатність значення (`> 0`)

**Особливості реалізації:**
- Використання `Math.PI` для точності
- `Math.pow(radius, 2)` для піднесення до квадрату
- `toFixed(2)` для округлення до двох знаків після коми

---

## Завдання 2: Площа трикутника за формулою Герона (лінійна функція)

### Функція: `calculate_second()`
```javascript
function calculate_second() {
    const a = parseFloat(document.getElementById('side_a').value);
    const b = parseFloat(document.getElementById('side_b').value);
    const c = parseFloat(document.getElementById('side_c').value);
    
    // Валідація існування трикутника
    if (a + b <= c || a + c <= b || b + c <= a) {
        document.getElementById('result_2').innerText = 'Результат: Трикутник з такими сторонами не існує';
        return;
    }
    
    const p = (a + b + c) / 2;  // Півпериметр
    const area = Math.sqrt(p * (p - a) * (p - b) * (p - c));
    
    document.getElementById('result_2').innerText = `Площа трикутника: ${area.toFixed(2)}`;
}
```

**Призначення:** Обчислення площі трикутника за трьома сторонами

**Формула Герона:**
1. **Півпериметр:** `p = (a + b + c) / 2`
2. **Площа:** `S = √[p(p-a)(p-b)(p-c)]`

**Валідація геометричної коректності:**
- **Нерівність трикутника:** Для існування трикутника кожна сторона має бути менша за суму двох інших
- `a + b > c` ∧ `a + c > b` ∧ `b + c > a`

**Технічні особливості:**
- `Math.sqrt()` для обчислення квадратного кореня
- Перевірка всіх трьох нерівностей трикутника
- Обробка випадку неіснуючого трикутника

---

## Завдання 3: Сума максимального та мінімального елементів (if...else)

### Функція: `calculate_third()`
```javascript
function calculate_third() {
    const num1 = parseFloat(document.getElementById('num1').value);
    const num2 = parseFloat(document.getElementById('num2').value);
    const num3 = parseFloat(document.getElementById('num3').value);
    const num4 = parseFloat(document.getElementById('num4').value);
    
    let max = num1;
    let min = num1;
    
    // Пошук максимуму
    if (num2 > max) max = num2;
    if (num3 > max) max = num3;
    if (num4 > max) max = num4;
    
    // Пошук мінімуму
    if (num2 < min) min = num2;
    if (num3 < min) min = num3;
    if (num4 < min) min = num4;
    
    const sum = max + min;
}
```

**Призначення:** Знаходження максимального та мінімального значень серед чотирьох чисел

**Алгоритм пошуку екстремумів:**
1. **Ініціалізація:** Встановлення першого елемента як початкового max та min
2. **Послідовне порівняння:** Перевірка кожного наступного елемента
3. **Оновлення:** Заміна max/min при знаходженні більшого/меншого значення

**Структура if...else:**
- Використання простих умовних операторів без else
- Незалежні перевірки для кожного числа
- Ефективність: O(n) для n елементів

**Альтернативні методи:**
```javascript
// Використання Math.max/Math.min
const max = Math.max(num1, num2, num3, num4);
const min = Math.min(num1, num2, num3, num4);
```

---

## Завдання 4: Дійсні корені квадратного рівняння (if...else)

### Функція: `calculate_fourth()`
```javascript
function calculate_fourth() {
    const a = parseFloat(document.getElementById('coef_a').value);
    const b = parseFloat(document.getElementById('coef_b').value);
    const c = parseFloat(document.getElementById('coef_c').value);
    
    if (a === 0) {
        document.getElementById('result_4').innerText = 'Результат: Коефіцієнт a не може дорівнювати 0';
        return;
    }
    
    const discriminant = b * b - 4 * a * c;
    
    if (discriminant > 0) {
        document.getElementById('result_4').innerText = 'Результат: Рівняння має два різних дійсних корені';
    } else if (discriminant === 0) {
        document.getElementById('result_4').innerText = 'Результат: Рівняння має два рівних дійсних корені';
    } else {
        document.getElementById('result_4').innerText = 'Результат: Рівняння не має дійсних коренів';
    }
}
```

**Призначення:** Визначення типу коренів квадратного рівняння `ax² + bx + c = 0`

**Математична теорія:**
- **Дискримінант:** `D = b² - 4ac`
- **D > 0:** Два різних дійсних корені
- **D = 0:** Один дійсний корінь (два рівних)
- **D < 0:** Комплексні корені (не дійсні)

**Каскадна структура if...else if...else:**
1. **Перша умова:** `discriminant > 0`
2. **Друга умова:** `discriminant === 0`
3. **Інакше:** `discriminant < 0`

**Валідація:**
- Перевірка `a ≠ 0` (інакше рівняння не квадратне)
- Використання `===` для точного порівняння з нулем

---

## Завдання 5: Сума цифр двозначного числа в діапазоні (5; 10)

### Функція: `calculate_fifth()`
```javascript
function calculate_fifth() {
    const num = parseInt(document.getElementById('two_digit').value);
    
    if (num < 10 || num > 99) {
        document.getElementById('result_5').innerText = 'Результат: Число має бути двозначним (10-99)';
        return;
    }
    
    const digit1 = Math.floor(num / 10);    // Перша цифра
    const digit2 = num % 10;                // Друга цифра
    const sum = digit1 + digit2;
    
    if (sum > 5 && sum < 10) {
        document.getElementById('result_5').innerText = `Результат: Так, сума цифр (${sum}) знаходиться в діапазоні (5; 10)`;
    } else {
        document.getElementById('result_5').innerText = `Результат: Ні, сума цифр (${sum}) не знаходиться в діапазоні (5; 10)`;
    }
}
```

**Призначення:** Перевірка, чи належить сума цифр двозначного числа інтервалу (5; 10)

**Алгоритм розбору числа на цифри:**
1. **Перша цифра (десятки):** `Math.floor(num / 10)`
2. **Друга цифра (одиниці):** `num % 10`

**Математичне обґрунтування:**
- Для числа 47: `4 = Math.floor(47/10)`, `7 = 47 % 10`
- Цілочислове ділення виділяє старшу цифру
- Остача від ділення на 10 дає молодшу цифру

**Особливості інтервалу:**
- **Відкритий інтервал (5; 10):** `5 < sum < 10`
- Не включає межі (5 та 10)
- Допустимі значення: 6, 7, 8, 9

---

## Завдання 6: Перевірка унікальності цифр числа (if...else)

### Функція: `calculate_sixth()`
```javascript
function calculate_sixth() {
    const num = parseInt(document.getElementById('four_digit').value);
    
    if (num < 0 || num >= 10000) {
        document.getElementById('result_6').innerText = 'Результат: Число має бути в діапазоні 0-9999';
        return;
    }
    
    const numStr = num.toString().padStart(4, '0');  // Доповнення нулями
    const digits = numStr.split('');                 // Масив цифр
    
    const uniqueDigits = new Set(digits);           // Унікальні цифри
    
    if (uniqueDigits.size === 4) {
        document.getElementById('result_6').innerText = `Результат: Так, усі чотири цифри числа ${num} різні`;
    } else {
        document.getElementById('result_6').innerText = `Результат: Ні, не всі цифри числа ${num} різні`;
    }
}
```

**Призначення:** Визначення унікальності всіх цифр у числі

**Алгоритм з використанням Set:**
1. **Перетворення у рядок:** `toString()`
2. **Доповнення нулями:** `padStart(4, '0')` для чисел < 1000
3. **Створення масиву цифр:** `split('')`
4. **Множина унікальних елементів:** `new Set(digits)`
5. **Порівняння розмірів:** `uniqueDigits.size === 4`

**Приклади:**
- `1234` → `["1","2","3","4"]` → Set розміром 4 → **унікальні**
- `1123` → `["1","1","2","3"]` → Set розміром 3 → **не унікальні**
- `5` → `"0005"` → `["0","0","0","5"]` → Set розміром 2 → **не унікальні**

**Технічні особливості:**
- `padStart()` забезпечує чотиризначність
- `Set` автоматично видаляє дублікати
- Перевірка розміру множини = кількості позицій

---

## Завдання 7: Пора року за номером місяця (switch...case)

### Функція: `calculate_seventh()`
```javascript
function calculate_seventh() {
    const month = parseInt(document.getElementById('month_num').value);
    
    let season;
    
    switch(month) {
        case 12: case 1: case 2:
            season = 'Зима';
            break;
        case 3: case 4: case 5:
            season = 'Весна';
            break;
        case 6: case 7: case 8:
            season = 'Літо';
            break;
        case 9: case 10: case 11:
            season = 'Осінь';
            break;
        default:
            season = 'Невідома пора року';
    }
}
```

**Призначення:** Визначення пори року за номером місяця

**Структура switch...case:**
- **Множинні case:** Групування місяців однієї пори року
- **break:** Запобігання "провалу" до наступного case
- **default:** Обробка неочікуваних значень

**Логічне групування:**
- **Зима:** грудень (12), січень (1), лютий (2)
- **Весна:** березень (3), квітень (4), травень (5)
- **Літо:** червень (6), липень (7), серпень (8)
- **Осінь:** вересень (9), жовтень (10), листопад (11)

**Переваги switch над if...else:**
- Більш читабельний код для багатьох умов
- Оптимізація виконання (таблиця переходів)
- Легше додавати нові варіанти

---

## Завдання 8: Дата наступного дня (switch...case)

### Функція: `calculate_eighth()`
```javascript
function calculate_eighth() {
    const day = parseInt(document.getElementById('day_n').value);
    const month = parseInt(document.getElementById('month_t').value);
    
    let daysInMonth;
    
    switch(month) {
        case 1: case 3: case 5: case 7:
        case 8: case 10: case 12:
            daysInMonth = 31;
            break;
        case 4: case 6: case 9: case 11:
            daysInMonth = 30;
            break;
        case 2:
            daysInMonth = 28;  // Спрощено: не враховуємо високосні роки
            break;
    }
    
    let nextDay = day;
    let nextMonth = month;
    
    if (day < daysInMonth) {
        nextDay = day + 1;
    } else {
        nextDay = 1;
        if (month < 12) {
            nextMonth = month + 1;
        } else {
            nextMonth = 1;  // Перехід на новий рік
        }
    }
}
```

**Призначення:** Обчислення дати наступного дня з врахуванням переходів місяців

**Логіка календарних обчислень:**

**Кількість днів у місяцях:**
- **31 день:** січень, березень, травень, липень, серпень, жовтень, грудень
- **30 днів:** квітень, червень, вересень, листопад  
- **28 днів:** лютий (спрощено, без високосних років)

**Алгоритм переходів:**
1. **Звичайний день:** `day + 1` в тому ж місяці
2. **Останній день місяця:** `день = 1`, `місяць + 1`
3. **31 грудня:** `день = 1`, `місяць = 1` (новий рік)

**Спрощення:**
- Не враховуються високосні роки
- Лютий завжди має 28 днів
- Для повної реалізації потрібна перевірка `(year % 4 === 0 && year % 100 !== 0) || year % 400 === 0`

---

## Технічні особливості реалізації

### 1. Валідація користувацького вводу
**Універсальні перевірки:**
```javascript
if (isNaN(value)) {
    // Обробка некоректного вводу
    return;
}
```

**Специфічні валідації:**
- **Діапазони значень:** `1 ≤ місяць ≤ 12`
- **Геометричні обмеження:** нерівність трикутника
- **Математичні умови:** `a ≠ 0` для квадратного рівняння

### 2. Функції парсингу
```javascript
parseFloat()  // Для дійсних чисел (площі, сторони)
parseInt()    // Для цілих чисел (дні, місяці, цифри)
```

### 3. Форматування виводу
```javascript
toFixed(2)    // Округлення до 2 знаків після коми
Template literals: `Результат: ${value}`
```

### 4. DOM маніпуляції
```javascript
document.getElementById('id').value           // Читання значення
document.getElementById('id').innerText      // Встановлення тексту
```

---

## Математичні концепції

### 1. Геометричні формули
- **Коло:** `S = πr²`, `L = 2πr`
- **Трикутник (Герон):** `S = √[p(p-a)(p-b)(p-c)]`

### 2. Алгебраїчні рівняння
- **Квадратне рівняння:** `ax² + bx + c = 0`
- **Дискримінант:** `D = b² - 4ac`

### 3. Теорія чисел
- **Розбиття на цифри:** ділення та остача
- **Множини:** унікальність елементів

### 4. Логічні операції
- **Булева алгебра:** AND, OR, NOT
- **Порівняння:** `<, >, ===, !==`

---

## Ключові концепції для захисту

### 1. Структури управління
**П:** Яка різниця між if...else та switch...case?
**В:** 
- **if...else:** Універсальний, підтримує складні умови, діапазони
- **switch...case:** Для дискретних значень, більш читабельний для багатьох варіантів

**П:** Навіщо потрібен break в switch?
**В:** Без break відбувається "провал" до наступного case, що може призвести до виконання небажаного коду

### 2. Валідація даних
**П:** Чому важлива валідація вводу?
**В:** Запобігає помилкам виконання, забезпечує коректність обчислень, покращує користувацький досвід

### 3. Математичні алгоритми
**П:** Як працює формула Герона?
**В:** Обчислює площу трикутника через півпериметр та всі три сторони, не потребуючи висоти

**П:** Що таке дискримінант?
**В:** Вираз під знаком кореня у формулі коренів квадратного рівняння, визначає тип коренів

### 4. Алгоритми обробки чисел
**П:** Як виділити цифри числа?
**В:** Цілочислове ділення на 10^n для старших розрядів, остача від ділення на 10 для молодшого розряду

---

## Практичні застосування

### 1. Геометричні розрахунки
- Проектування та будівництво
- Графічний дизайн
- Ігрова розробка (collision detection)

### 2. Календарні системи
- Планувальники та календарі
- Бізнес-логіка (робочі дні, терміни)
- Вікові розрахунки

### 3. Валідація форм
- Веб-розробка
- Мобільні додатки
- Desktop застосунки

### 4. Математичне моделювання
- Наукові розрахунки
- Статистичний аналіз
- Фінансові обчислення

---

## Можливі покращення

### 1. Розширення математичних функцій
```javascript
// Обчислення самих коренів квадратного рівняння
const x1 = (-b + Math.sqrt(discriminant)) / (2 * a);
const x2 = (-b - Math.sqrt(discriminant)) / (2 * a);
```

### 2. Підтримка високосних років
```javascript
function isLeapYear(year) {
    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
}
```

### 3. Інтернаціоналізація
- Підтримка різних форматів дат
- Локалізація назв пір року
- Різні числові формати

### 4. Покращена валідація
- Перевірка на граничні значення
- Попередження про некоректний ввід
- Автоматичне виправлення помилок

---

## Висновок

Лабораторна робота №2 демонструє:
1. **Основи програмування** з лінійними та розгалуженими алгоритмами
2. **Математичні обчислення** в програмному коді
3. **Структури управління** if...else та switch...case
4. **Валідацію даних** та обробку помилок
5. **DOM взаємодію** для створення інтерактивних веб-застосунків
6. **Алгоритми обробки чисел** та роботу з календарними датами