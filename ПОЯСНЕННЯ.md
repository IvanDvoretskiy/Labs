# Лабораторна робота №5 - Візуалізація даних з Chart.js

## Загальний опис проєкту

Веб-застосунок для візуалізації даних за допомогою бібліотеки Chart.js. Реалізовано два графіки:
1. **Горизонтальний бар-чарт** - рейтинг топ-20 фільмів з кольоровим кодуванням
2. **Складений стовпчастий графік** - продажі товарів по категоріях за тиждень

---

## Структура файлів

```
LB5/
├── index.html       # HTML розмітка
├── script.js        # Логіка та дані
├── styles.css       # Стилізація
└── ПОЯСНЕННЯ.md     # Документація
```

---

## 1. HTML файл (`index.html`)

### Основні елементи:

```html
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
```
**Пояснення:** Підключення бібліотеки Chart.js через CDN (Content Delivery Network). Це дозволяє використовувати всі можливості бібліотеки без локального завантаження.

```html
<canvas id="moviesChart"></canvas>
<canvas id="salesChart"></canvas>
```
**Пояснення:** Елементи `<canvas>` - це HTML5 елементи для малювання графіки. Chart.js використовує їх для рендерингу графіків.

### Чому саме така структура?
- `<meta name="viewport">` - адаптивність під мобільні пристрої
- Послідовність підключення: спочатку CSS, потім Chart.js, і в кінці наш скрипт
- Скрипт в кінці `<body>` гарантує, що DOM повністю завантажений

---

## 2. JavaScript файл (`script.js`)

### Масив даних фільмів

```javascript
const movies = [
    { title: 'Втеча з Шоушенка', rating: 9.3 },
    { title: 'Хрещений батько', rating: 9.2 },
    // ... ще 18 фільмів
];
```

**Тип даних:** Масив об'єктів  
**Структура:** Кожен об'єкт має два поля - `title` (назва) та `rating` (рейтинг)  
**Чому так:** Об'єкти зручно обробляти методами масивів (`map`, `filter`, тощо)

---

### Функція `getColorByRating(rating)`

```javascript
function getColorByRating(rating) {
    if (rating > 8.5) {
        return 'rgb(75, 192, 75)';      // Зелений
    } else if (rating > 7.5) {
        return 'rgb(255, 205, 86)';     // Жовтий
    } else {
        return 'rgb(255, 99, 132)';     // Червоний
    }
}
```

**Призначення:** Динамічне визначення кольору стовпця залежно від рейтингу  
**Параметри:** `rating` (number) - рейтинг фільму від 0 до 10  
**Повертає:** RGB колір у вигляді рядка  

**Логіка:**
- **Зелений** (rating > 8.5) → Видатні фільми
- **Жовтий** (7.5 < rating ≤ 8.5) → Хороші фільми  
- **Червоний** (rating ≤ 7.5) → Посередні фільми

**Застосування:** Візуальна диференціація якості фільмів без читання цифр

---

### Отримання контексту Canvas

```javascript
const moviesCtx = document.getElementById('moviesChart').getContext('2d');
```

**Що робить:**
1. `getElementById('moviesChart')` - знаходить canvas елемент за ID
2. `.getContext('2d')` - отримує 2D контекст малювання

**Чому важливо:** Chart.js потребує контекст для рендерингу графіків. Без `getContext('2d')` графік не відобразиться.

---

### Графік 1: Рейтинг фільмів (Горизонтальний Bar Chart)

```javascript
const moviesChart = new Chart(moviesCtx, {
    type: 'bar',
    data: { /* ... */ },
    options: { /* ... */ }
});
```

#### Аналіз секції `data`:

```javascript
data: {
    labels: movies.map(m => m.title),
    datasets: [{
        label: 'Рейтинг фільму',
        data: movies.map(m => m.rating),
        backgroundColor: movies.map(m => getColorByRating(m.rating)),
        borderColor: movies.map(m => getColorByRating(m.rating)),
        borderWidth: 1,
        borderRadius: 10
    }]
}
```

**Метод `map()`:**
- `movies.map(m => m.title)` - створює масив тільки з назв фільмів
- `movies.map(m => m.rating)` - створює масив тільки з рейтингів
- `movies.map(m => getColorByRating(m.rating))` - для кожного фільму викликає функцію визначення кольору

**Чому `map()` а не цикл?**
- Функціональний підхід - сучасніший стиль програмування
- Повертає новий масив без зміни оригіналу
- Компактний і читабельний код
- Легше підтримувати і тестувати

**Параметри стилізації:**
- `backgroundColor` - колір заливки стовпця
- `borderColor` - колір рамки стовпця
- `borderWidth: 1` - товщина рамки в пікселях
- `borderRadius: 10` - закруглення кутів (сучасний вигляд)

#### Аналіз секції `options`:

```javascript
options: {
    indexAxis: 'y',
    responsive: true,
    maintainAspectRatio: false,
    // ...
}
```

**Ключові опції:**

| Опція | Значення | Пояснення |
|-------|----------|-----------|
| `indexAxis: 'y'` | Вісь Y | Робить графік горизонтальним (стовпці йдуть зліва направо) |
| `responsive: true` | Увімкнено | Графік автоматично підлаштовується під розмір контейнера |
| `maintainAspectRatio: false` | Вимкнено | Дозволяє встановити власну висоту (інакше буде автоматичне співвідношення) |

**Навіщо `indexAxis: 'y'`?**
- Назви фільмів довгі ("Втеча з Шоушенка") 
- Горизонтальна орієнтація дозволяє повністю відобразити текст
- Легше порівнювати рейтинги візуально

```javascript
plugins: {
    legend: {
        display: true,
        position: 'top'
    },
    title: {
        display: true,
        text: 'Топ 20 фільмів за рейтингом',
        font: { size: 18 }
    }
}
```

**Плагіни:**
- `legend` - легенда графіка (пояснення кольорів/категорій)
- `title` - заголовок графіка з налаштуваним шрифтом

```javascript
scales: {
    x: {
        beginAtZero: true,
        max: 10,
        title: {
            display: true,
            text: 'Рейтинг (0-10)'
        }
    }
}
```

**Налаштування осей:**
- `beginAtZero: true` - вісь X починається з нуля (правильна візуалізація пропорцій)
- `max: 10` - максимальне значення (рейтинг не може бути > 10)
- `title` - підпис осі для зрозумілості

---

### Графік 2: Продажі по категоріях (Stacked Bar Chart)

```javascript
const salesData = {
    days: ['Пн', 'Вт', 'Ср', 'Чт', 'Пт', 'Сб', 'Нд'],
    футболки: [87, 92, 78, 95, 110, 125, 98],
    кросівки: [43, 51, 38, 47, 62, 70, 55],
    куртки: [28, 35, 25, 40, 45, 58, 42]
};
```

**Структура даних:**
- Об'єкт з 4 властивостями
- `days` - мітки для осі X
- Три масиви з даними продажів (кількість товарів за кожен день)

**Чому окремі масиви для кожної категорії?**
- Chart.js очікує datasets як окремі масиви
- Легко додати нову категорію товару
- Зручно оновлювати дані для однієї категорії

```javascript
datasets: [
    {
        label: 'Футболки',
        data: salesData.футболки,
        backgroundColor: 'rgba(54, 162, 235, 0.7)',
        borderColor: 'rgb(54, 162, 235)',
        borderWidth: 1
    },
    {
        label: 'Кросівки',
        data: salesData.кросівки,
        backgroundColor: 'rgba(255, 99, 132, 0.7)',
        borderColor: 'rgb(255, 99, 132)',
        borderWidth: 1
    },
    {
        label: 'Куртки',
        data: salesData.куртки,
        backgroundColor: 'rgba(255, 205, 86, 0.7)',
        borderColor: 'rgb(255, 205, 86)',
        borderWidth: 1
    }
]
```

**Кольорова схема:**
- Футболки - синій `rgba(54, 162, 235, 0.7)`
- Кросівки - червоний `rgba(255, 99, 132, 0.7)`
- Куртки - жовтий `rgba(255, 205, 86, 0.7)`

**Чому `rgba()` замість `rgb()`?**
- Четвертий параметр (0.7) - це прозорість (alpha channel)
- Прозорість = 0.7 (70%) робить кольори м'якшими
- Краще виглядає при накладанні стовпців

```javascript
scales: {
    x: {
        stacked: true,
        title: { display: true, text: 'Дні тижня' }
    },
    y: {
        stacked: true,
        beginAtZero: true,
        title: { display: true, text: 'Кількість проданих одиниць (шт)' }
    }
}
```

**Що робить `stacked: true`?**
- Стовпці накладаються один на одного (не стоять поруч)
- Висота загального стовпця = сума всіх категорій
- Показує і частку кожної категорії, і загальний обсяг

**Переваги stacked chart:**
- Видно загальні продажі за день (висота стовпця)
- Видно внесок кожної категорії (розмір кольорового сегменту)
- Легко порівняти структуру продажів між днями

```javascript
tooltip: {
    callbacks: {
        afterBody: function(context) {
            const dayIndex = context[0].dataIndex;
            const day = salesData.days[dayIndex];
            return `\n${day}:\nФутболки - ${salesData.футболки[dayIndex]} шт\nКросівки - ${salesData.кросівки[dayIndex]} шт\nКуртки - ${salesData.куртки[dayIndex]} шт`;
        }
    }
}
```

**Кастомізація tooltip (спливаюча підказка):**

**Що робить `callbacks.afterBody`?**
- Додає додатковий текст після основної інформації tooltip
- `context[0].dataIndex` - індекс дня, на який навели курсор
- Показує детальну розбивку продажів по всіх категоріях

**Навіщо це потрібно?**
- За замовчуванням tooltip показує тільки одну категорію
- З кастомізацією - відразу видно всю інформацію
- Зручніше для користувача (не треба наводити на кожен сегмент окремо)

---

## 3. CSS файл (`styles.css`)

### Universal Selector

```css
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}
```

**Пояснення:**
- `*` - селектор для всіх елементів
- `margin: 0; padding: 0;` - скидання браузерних відступів
- `box-sizing: border-box;` - padding і border входять у width/height (правильний розрахунок розмірів)

**Чому `box-sizing: border-box` важливий?**
- Без нього: width = контент + padding + border (елементи "розпухають")
- З ним: width = контент + padding + border (елементи мають точно заданий розмір)

### Body стилізація

```css
body {
    font-family: Arial, sans-serif;
    background-color: #f5f5f5;
    padding: 20px;
}
```

**Пояснення:**
- `Arial, sans-serif` - шрифт без зарубок (читабельний, універсальний)
- `#f5f5f5` - світло-сірий фон (приємніше для очей ніж білий)
- `padding: 20px` - відступ від країв вікна

### Контейнер

```css
.container {
    max-width: 1200px;
    margin: 0 auto;
    background-color: white;
    padding: 30px;
    border-radius: 10px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
}
```

**Розбір властивостей:**

| Властивість | Значення | Призначення |
|-------------|----------|-------------|
| `max-width: 1200px` | Макс. ширина | Обмежує ширину на великих екранах |
| `margin: 0 auto` | Автомарджин | Центрує контейнер горизонтально |
| `background-color: white` | Білий фон | Контраст з сірим фоном body |
| `padding: 30px` | Внутрішні відступи | Контент не прилипає до країв |
| `border-radius: 10px` | Закруглення | Сучасний вигляд (не прямокутник) |
| `box-shadow: 0 2px 10px rgba(0,0,0,0.1)` | Тінь | Ефект "картки", що здіймається над фоном |

**Що означає `box-shadow: 0 2px 10px rgba(0,0,0,0.1)`?**
- `0` - зміщення по X (0 = тінь по центру)
- `2px` - зміщення по Y (2px вниз)
- `10px` - розмиття (більше = м'якша тінь)
- `rgba(0,0,0,0.1)` - чорний колір з прозорістю 10%

### Заголовки

```css
h1 {
    color: #333;
    text-align: center;
    margin-bottom: 10px;
}

h2 {
    color: #666;
    text-align: center;
    margin-bottom: 30px;
    font-size: 18px;
    font-weight: normal;
}

h3 {
    color: #444;
    margin-bottom: 20px;
    padding-bottom: 10px;
    border-bottom: 2px solid #007bff;
}
```

**Ієрархія кольорів:**
- `h1`: `#333` - найтемніший (найважливіший)
- `h2`: `#666` - середній (підзаголовок)
- `h3`: `#444` - темний (заголовок секції)

**Техніка для h3:**
- `border-bottom: 2px solid #007bff` - синя лінія під текстом
- Візуально розділяє секції графіків
- `#007bff` - стандартний синій колір (Bootstrap blue)

### Chart Container

```css
.chart-container {
    position: relative;
    height: 600px;
    margin-top: 20px;
}
```

**Чому `position: relative`?**
- Chart.js використовує абсолютне позиціонування всередині
- `position: relative` створює контекст позиціонування для дочірніх елементів

**Чому фіксована висота (`height: 600px`)?**
- Chart.js потребує явно заданої висоти
- Без висоти графік може не відобразитися або мати неправильний розмір
- 600px - достатньо для 20 фільмів у горизонтальному графіку

**Що станеться без `height: 600px`?**
- Графік може "схлопнутися" до висоти 0px
- Або буде занадто маленьким
- `maintainAspectRatio: false` в JS вимагає явної висоти

---

## Питання для захисту роботи

### Блок 1: HTML

**Q1: Чому Chart.js підключається через CDN, а не локально?**
- Швидше завантажується (використовуються сервери CDN по всьому світу)
- Автоматичні оновлення версії
- Економія місця в проєкті
- Підключається один раз і кешується браузером

**Q2: Що таке Canvas і чому Chart.js його використовує?**
- Canvas - HTML5 елемент для малювання 2D/3D графіки
- Chart.js рендерить графіки як піксельну графіку
- Альтернатива - SVG, але Canvas швидший для складних анімацій

**Q3: Чому скрипт підключається в кінці body, а не в head?**
- DOM має бути завантажений перед виконанням скрипту
- `getElementById` не знайде елементи, якщо вони ще не існують
- Альтернатива - `defer` або `DOMContentLoaded`, але кінець body простіше

### Блок 2: JavaScript - Основи

**Q4: Чому використовується `const` для змінних графіків?**
- `const` гарантує, що змінна не буде перезаписана
- Об'єкт Chart все одно можна модифікувати (const не робить об'єкт незмінним)
- Захист від випадкових помилок типу `moviesChart = null`

**Q5: В чому різниця між `map()`, `forEach()` і звичайним циклом `for`?**
- `map()` - повертає новий масив, не змінює оригінал
- `forEach()` - просто виконує код для кожного елемента, нічого не повертає
- `for` - найнижчерівневіший, дає повний контроль (break, continue)
- У нашому випадку `map()` ідеальний - треба створити масиви з даних

**Q6: Що таке `getContext('2d')` і навіщо він потрібен?**
- Отримує API для малювання на canvas
- `'2d'` - двовимірний контекст (є ще `'webgl'` для 3D)
- Без контексту Chart.js не зможе малювати

### Блок 3: JavaScript - Функції

**Q7: Чому функція `getColorByRating()` повертає саме RGB, а не HEX (`#FF0000`)?**
- Chart.js приймає обидва формати
- RGB зручніший для програмної генерації
- Можна легко додати альфа-канал: `rgb()` → `rgba()`

**Q8: Як можна покращити `getColorByRating()` для більш плавного градієнту?**
```javascript
function getColorByRating(rating) {
    const hue = (rating / 10) * 120; // 0 = червоний, 120 = зелений
    return `hsl(${hue}, 70%, 50%)`;
}
```
- HSL (Hue, Saturation, Lightness) дозволяє плавний перехід кольорів
- 0° = червоний, 120° = зелений

### Блок 4: JavaScript - Chart.js налаштування

**Q9: Яка різниця між `type: 'bar'` горизонтальним і вертикальним?**
- За замовчуванням `type: 'bar'` - вертикальний
- `indexAxis: 'y'` робить його горизонтальним
- Альтернатива у старих версіях - `type: 'horizontalBar'` (deprecated)

**Q10: Що таке `datasets` і чому це масив?**
- `datasets` - це набори даних для відображення на одному графіку
- Масив дозволяє відобразити декілька ліній/стовпців на одному графіку
- У першому графіку - один dataset (рейтинги), у другому - три (футболки, кросівки, куртки)

**Q11: Навіщо `beginAtZero: true` в налаштуваннях осі?**
- Без цього Chart.js автоматично підбирає мінімум (наприклад, якщо всі значення 5-10, почне з 5)
- З `beginAtZero: true` - вісь завжди починається з 0
- Важливо для правильного візуального порівняння (стовпець з рейтингом 5 має виглядати як половина від 10)

**Q12: Що означає `stacked: true` і коли це використовується?**
- Стовпці різних категорій накладаються один на одного
- Загальна висота = сума всіх значень
- Використовується, коли треба показати:
  - Загальну суму (висота стовпця)
  - Внесок кожної категорії (розмір сегменту)
  - Динаміку структури (як змінюється співвідношення категорій)

**Q13: Чому `maintainAspectRatio: false`?**
- За замовчуванням Chart.js підтримує співвідношення сторін (наприклад 2:1)
- Це обмежує висоту графіка
- `false` дозволяє використати всю висоту контейнера (600px)
- Важливо для горизонтального графіка з 20 фільмами (треба багато місця)

### Блок 5: JavaScript - Tooltip

**Q14: Що робить `callbacks.afterBody` в tooltip?**
- Додає текст після основної інформації
- `context[0]` - дані про елемент, на який навели курсор
- `dataIndex` - індекс елемента в масиві даних
- Дозволяє показати всю розбивку продажів одночасно

**Q15: Які ще є callbacks для tooltip?**
- `beforeTitle`, `title`, `afterTitle` - для заголовка
- `beforeBody`, `afterBody` - для основного тексту
- `beforeFooter`, `footer`, `afterFooter` - для підвалу
- `label` - для кастомізації міток категорій

### Блок 6: CSS

**Q16: Навіщо `box-sizing: border-box` для всіх елементів?**
- За замовчуванням CSS використовує `content-box`:
  - Якщо задати `width: 200px` і `padding: 20px`, реальна ширина = 240px
- З `border-box`:
  - Реальна ширина = 200px (padding входить у width)
- Спрощує розрахунки розмірів

**Q17: Як працює `margin: 0 auto` для центрування?**
- `0` - верхній/нижній margin
- `auto` - лівий/правий margin
- Браузер автоматично розподіляє вільне місце порівну зліва і справа
- **Важливо:** працює тільки для блокових елементів з заданою шириною

**Q18: Що означають параметри `box-shadow: 0 2px 10px rgba(0,0,0,0.1)`?**
1. `0` - горизонтальний зсув (0 = тінь по центру)
2. `2px` - вертикальний зсув (2px вниз)
3. `10px` - радіус розмиття (більше = м'якша тінь)
4. `rgba(0,0,0,0.1)` - чорний колір з прозорістю 10%

**Q19: Чому для `.chart-container` використовується `position: relative`?**
- Chart.js створює внутрішні елементи з `position: absolute`
- `position: relative` створює контекст позиціонування
- Без цього абсолютні елементи будуть позиціонуватися відносно `body`

**Q20: Навіщо `height: 600px` для контейнера графіка?**
- Chart.js потребує явну висоту для правильного рендерингу
- Особливо важливо з `maintainAspectRatio: false`
- 600px достатньо для відображення 20 фільмів у горизонтальному графіку

### Блок 7: Загальна архітектура

**Q21: Чому дані зберігаються в JS, а не завантажуються з сервера?**
- Це навчальний проєкт - фокус на візуалізації, а не на backend
- У реальному застосунку використовувались би:
  - `fetch()` для отримання JSON з API
  - WebSocket для реал-тайм даних
  - GraphQL для гнучких запитів

**Q22: Як додати інтерактивність (наприклад, фільтрацію фільмів)?**
```javascript
function filterMovies(minRating) {
    const filtered = movies.filter(m => m.rating >= minRating);
    moviesChart.data.labels = filtered.map(m => m.title);
    moviesChart.data.datasets[0].data = filtered.map(m => m.rating);
    moviesChart.update(); // Оновлює графік
}
```

**Q23: Як експортувати графік в PNG?**
```javascript
const canvas = document.getElementById('moviesChart');
const url = canvas.toDataURL('image/png');
const link = document.createElement('a');
link.download = 'chart.png';
link.href = url;
link.click();
```

### Блок 8: Оптимізація та покращення

**Q24: Як зробити графіки адаптивними для мобільних?**
```css
@media (max-width: 768px) {
    .chart-container {
        height: 400px; /* Менша висота для мобільних */
    }
    h1 { font-size: 24px; }
}
```

**Q25: Як анімувати появу графіків?**
```javascript
options: {
    animation: {
        duration: 2000, // 2 секунди
        easing: 'easeInOutQuart' // Тип анімації
    }
}
```

---

## Технічні деталі для захисту

### Використані технології:
1. **HTML5** - семантична розмітка, Canvas API
2. **CSS3** - Flexbox не потрібен (проста структура), Box Model, Shadow Effects
3. **JavaScript ES6** - Arrow functions, const/let, Array methods (map, filter)
4. **Chart.js v4.x** - Бібліотека візуалізації даних

### Ключові концепції програмування:
- **Функціональне програмування** - `map()` замість циклів
- **Callback функції** - `getColorByRating()`, `tooltip.callbacks`
- **Об'єктно-орієнтований підхід** - `new Chart()`
- **Конфігурація через об'єкти** - `options` для налаштування

### Можливі питання про альтернативи:

**"Чому Chart.js, а не D3.js?"**
- Chart.js простіший для базових графіків
- Менше коду для типових завдань
- D3.js потужніший, але складніший для вивчення

**"Чому не використовується React/Vue?"**
- Для простих графіків фреймворки надмірні
- Vanilla JS дозволяє зрозуміти основи
- У реальних проєктах краще використовувати Chart.js з React (`react-chartjs-2`)

---

## Висновок

Проєкт демонструє:
✅ Роботу з зовнішніми бібліотеками (Chart.js)  
✅ Маніпуляцію DOM (getElementById, getContext)  
✅ Функціональне програмування (map, filter, callbacks)  
✅ Візуалізацію даних (bar charts, stacked charts)  
✅ Кастомізацію UI (кольори, tooltip, стилізація)  
✅ Responsive design (адаптивні графіки)  

Код написаний чисто, використовує сучасні практики JavaScript і готовий до розширення додатковими функціями.
