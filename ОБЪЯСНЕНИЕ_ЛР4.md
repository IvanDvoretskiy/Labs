# Лабораторная работа №4 - Сортировка массивов

## Описание работы
Лабораторная работа включает две задачи по сортировке двумерных массивов с использованием различных алгоритмов сортировки и веб-интерфейса для демонстрации.

---

## Задача 1.1: Сортировка двумерного массива методом QuickSort

**Файлы:** `index.html`, `script.js`

### Основные методы:

#### 1. `generateArray()`
```javascript
function generateArray() {
    const rows = parseInt(document.getElementById('rows').value);
    const cols = parseInt(document.getElementById('cols').value);
    const minValue = parseInt(document.getElementById('minValue').value);
    const maxValue = parseInt(document.getElementById('maxValue').value);
    
    // Генерация двумерного массива случайных чисел
}
```
**Назначение:** Создание двумерного массива с параметрами, заданными пользователем
- Считывает размеры массива (строки × столбцы)
- Устанавливает диапазон значений (мин-макс)
- Заполняет массив случайными числами
- Отображает результат в HTML таблице

#### 2. `quickSort(arr, low, high)`
```javascript
function quickSort(arr, low, high) {
    if (low < high) {
        let pi = partition(arr, low, high);
        
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}
```
**Назначение:** Основной алгоритм быстрой сортировки
- **Принцип работы:** Алгоритм "разделяй и властвуй"
- **Временная сложность:** O(n log n) в среднем случае, O(n²) в худшем
- **Рекурсивная структура:** Делит массив на части относительно опорного элемента

#### 3. `partition(arr, low, high)`
```javascript
function partition(arr, low, high) {
    let pivot = arr[high];  // Выбираем последний элемент как опорный
    let i = low - 1;        // Индекс меньшего элемента
    
    for (let j = low; j < high; j++) {
        if (arr[j] < pivot) {
            i++;
            // Обмен элементов
            let temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }
    
    // Помещаем опорный элемент на правильное место
    let temp = arr[i + 1];
    arr[i + 1] = arr[high];
    arr[high] = temp;
    
    return i + 1;
}
```
**Назначение:** Разделение массива для алгоритма QuickSort
- Выбирает опорный элемент (pivot) - последний в массиве
- Перестанавливает элементы: меньше pivot слева, больше справа
- Возвращает финальную позицию опорного элемента

#### 4. `sortArray()`
```javascript
function sortArray() {
    // Создание копии оригинального массива
    let array = [];
    for (let i = 0; i < originalArray.length; i++) {
        array[i] = [];
        for (let j = 0; j < originalArray[i].length; j++) {
            array[i][j] = originalArray[i][j];
        }
    }
    
    // Преобразование 2D массива в 1D
    let compose = [];
    for (let i = 0; i < array.length; i++) {
        for (let j = 0; j < array[i].length; j++) {
            compose[compose.length] = array[i][j];
        }
    }
    
    // Применение QuickSort
    quickSort(compose, 0, compose.length - 1);
    
    // Восстановление 2D структуры
    let index = 0;
    for (let i = 0; i < array.length; i++) {
        for (let j = 0; j < array[i].length; j++) {
            array[i][j] = compose[index];
            index++;
        }
    }
}
```
**Назначение:** Обработчик сортировки двумерного массива
- **Ключевая особенность:** Линеаризация 2D массива в 1D для применения QuickSort
- Создает независимую копию оригинального массива
- После сортировки восстанавливает двумерную структуру

---

## Задача 1.2: Сортировка диагоналей двумерного массива

**Файлы:** `task2.html`, `script2.js`

### Основные методы:

#### 1. `sortDiagonals()`
```javascript
function sortDiagonals() {
    const size = array.length;
    
    // Извлечение главной диагонали (i = j)
    let mainDiagonal = [];
    for (let i = 0; i < size; i++) {
        mainDiagonal[mainDiagonal.length] = array[i][i];
    }
    
    // Сортировка по возрастанию
    bubbleSortAscending(mainDiagonal);
    
    // Возврат в массив
    for (let i = 0; i < size; i++) {
        array[i][i] = mainDiagonal[i];
    }
    
    // Извлечение побочной диагонали (i + j = n-1)
    let sideDiagonal = [];
    for (let i = 0; i < size; i++) {
        sideDiagonal[sideDiagonal.length] = array[i][size - 1 - i];
    }
    
    // Сортировка по убыванию
    bubbleSortDescending(sideDiagonal);
    
    // Возврат в массив
    for (let i = 0; i < size; i++) {
        array[i][size - 1 - i] = sideDiagonal[i];
    }
}
```
**Назначение:** Сортировка диагональных элементов квадратного массива
- **Главная диагональ:** элементы где i = j (сортировка по возрастанию)
- **Побочная диагональ:** элементы где i + j = n-1 (сортировка по убыванию)
- Работает только с диагональными элементами, остальные не изменяются

#### 2. `bubbleSortAscending(arr)`
```javascript
function bubbleSortAscending(arr) {
    let n = arr.length;
    let swapped;
    
    for (let i = 0; i < n - 1; i++) {
        swapped = false;
        for (let j = 0; j < n - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
                // Обмен элементов
                let temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
                swapped = true;
            }
        }
        // Оптимизация: если не было обменов, массив уже отсортирован
        if (!swapped) break;
    }
}
```
**Назначение:** Сортировка массива по возрастанию методом пузырька
- **Временная сложность:** O(n²) в худшем случае, O(n) в лучшем
- **Принцип:** Сравнивает соседние элементы и меняет местами при необходимости
- **Оптимизация:** Раннее завершение если не было обменов

#### 3. `bubbleSortDescending(arr)`
```javascript
function bubbleSortDescending(arr) {
    let n = arr.length;
    let swapped;
    
    for (let i = 0; i < n - 1; i++) {
        swapped = false;
        for (let j = 0; j < n - 1 - i; j++) {
            if (arr[j] < arr[j + 1]) {  // Обратное условие для убывания
                let temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
                swapped = true;
            }
        }
        if (!swapped) break;
    }
}
```
**Назначение:** Сортировка массива по убыванию методом пузырька
- Аналогичен `bubbleSortAscending`, но с обратным условием сравнения

#### 4. `displayArray(array, elementId, highlight)`
```javascript
function displayArray(array, elementId, highlight) {
    // ... код генерации HTML таблицы
    
    for (let i = 0; i < size; i++) {
        for (let j = 0; j < size; j++) {
            let className = '';
            if (highlight) {
                if (i === j) {
                    className = ' class="main-diagonal"';      // Желтый цвет
                } else if (i + j === size - 1) {
                    className = ' class="side-diagonal"';     // Оранжевый цвет
                }
            }
            html += '<td' + className + '>' + array[i][j] + '</td>';
        }
    }
}
```
**Назначение:** Отображение массива с выделением диагональных элементов
- **highlight = false:** Обычная таблица
- **highlight = true:** Диагональные элементы выделяются цветом

---

## Сравнение алгоритмов

### QuickSort vs Bubble Sort

| Характеристика | QuickSort | Bubble Sort |
|---|---|---|
| **Временная сложность (среднее)** | O(n log n) | O(n²) |
| **Временная сложность (худшее)** | O(n²) | O(n²) |
| **Временная сложность (лучшее)** | O(n log n) | O(n) |
| **Пространственная сложность** | O(log n) | O(1) |
| **Стабильность** | Нестабильный | Стабильный |
| **Принцип** | Разделяй и властвуй | Сравнение соседних элементов |
| **Рекурсия** | Да | Нет |
| **Подходит для** | Больших массивов | Небольших массивов |

---

## Ключевые концепции для защиты

### 1. Почему QuickSort для первой задачи?
- **Эффективность:** O(n log n) в среднем случае лучше чем O(n²) других простых алгоритмов
- **Работа "на месте":** Не требует дополнительной памяти для массива
- **Масштабируемость:** Хорошо работает с большими объемами данных

### 2. Почему Bubble Sort для диагоналей?
- **Простота реализации:** Легко понять и модифицировать
- **Небольшой размер данных:** Диагонали содержат мало элементов (n штук)
- **Легкая модификация:** Простое изменение условия для сортировки по убыванию
- **Стабильность:** Сохраняет относительный порядок равных элементов

### 3. Техническая реализация

#### Копирование массивов
```javascript
// Глубокое копирование 2D массива
for (let i = 0; i < originalArray.length; i++) {
    array[i] = [];
    for (let j = 0; j < originalArray[i].length; j++) {
        array[i][j] = originalArray[i][j];
    }
}
```
**Зачем:** Сохранение оригинального массива для сравнения

#### Преобразование 2D → 1D
```javascript
// Линеаризация массива
let compose = [];
for (let i = 0; i < array.length; i++) {
    for (let j = 0; j < array[i].length; j++) {
        compose[compose.length] = array[i][j];
    }
}
```
**Зачем:** QuickSort работает только с одномерными массивами

#### Восстановление структуры
```javascript
// Восстановление 2D структуры после сортировки
let index = 0;
for (let i = 0; i < array.length; i++) {
    for (let j = 0; j < array[i].length; j++) {
        array[i][j] = compose[index];
        index++;
    }
}
```
**Зачем:** Возврат к двумерному представлению для отображения

### 4. Веб-интерфейс
- **HTML формы:** Ввод параметров пользователем
- **CSS стили:** Красивое отображение таблиц и выделение диагоналей
- **JavaScript события:** Обработка нажатий кнопок
- **DOM манипуляции:** Динамическое создание HTML таблиц

---

## Возможные вопросы на защите

### 1. **Алгоритмические вопросы:**
- Объясните принцип работы QuickSort
- Почему QuickSort называется "быстрой" сортировкой?
- В каких случаях Bubble Sort может быть эффективнее QuickSort?
- Что происходит в функции partition?

### 2. **Технические вопросы:**
- Зачем нужно преобразование 2D массива в 1D?
- Как определяются элементы главной и побочной диагоналей?
- Почему создается копия массива перед сортировкой?

### 3. **Практические вопросы:**
- Как изменить код для сортировки по убыванию в первой задаче?
- Что будет если массив во второй задаче не квадратный?
- Как добавить сортировку других диагоналей (параллельных главным)?

### 4. **Сложность алгоритмов:**
- Временная и пространственная сложность каждого алгоритма
- Лучший, средний и худший случаи для QuickSort
- Почему Bubble Sort имеет O(n) в лучшем случае?

---

## Заключение

Данная лабораторная работа демонстрирует:
1. **Понимание алгоритмов сортировки** и их применение
2. **Работу с двумерными массивами** и их преобразование
3. **Создание веб-интерфейса** для демонстрации алгоритмов
4. **Оптимизацию алгоритмов** под конкретные задачи
5. **Визуализацию данных** с помощью HTML/CSS/JavaScript